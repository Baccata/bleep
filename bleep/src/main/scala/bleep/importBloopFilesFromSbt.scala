package bleep

import bleep.Options.Opt
import bloop.config.Config
import coursier.core.Configuration
import coursier.parse.JavaOrScalaDependency
import coursier.{Dependency, Module, ModuleName, Organization}

import java.net.URI
import java.nio.file.{Files, Path, Paths}
import java.util.stream.Collectors
import scala.jdk.CollectionConverters._

object importBloopFilesFromSbt {
  def apply(buildDir: Path): model.Build = {
    val bloopFilesDir = buildDir / Defaults.BloopFolder

    if (Files.exists(bloopFilesDir / ".digest")) {
      sys.error(s"It's not useful to import bloop files generated by bleep. delete $bloopFilesDir, run `sbt bloopInstall` and try again")
    }

    val projectNames: List[model.ProjectName] =
      Files
        .list(bloopFilesDir)
        .filter(Files.isRegularFile(_))
        .map(path => model.ProjectName(path.getFileName.toString.replace(".json", "")))
        .collect(Collectors.toList[model.ProjectName])
        .asScala
        .toList

    val bloopProjectFiles: Map[model.ProjectName, Config.File] =
      projectNames
        .map(name => name -> readBloopFile(bloopFilesDir, name))
        .toMap
        .filter { case (_, bloopFile) =>
          def hasFiles(path: Path): Boolean = Files.exists(path) && Files.walk(path).findFirst().isPresent
          (bloopFile.project.sources ++ bloopFile.project.resources.getOrElse(Nil)) exists hasFiles
        }

    val buildResolvers: List[URI] =
      bloopProjectFiles
        .flatMap { case (projectName, bloopFile) =>
          bloopFile.project.resolution
            .getOrElse(sys.error(s"Expected bloop file for ${projectName.value} to have resolution"))
            .modules
            .flatMap { mod =>
              val initialOrg = Paths.get(mod.organization.split("\\.").head)
              val uriFragments = mod.artifacts.head.path.iterator().asScala.dropWhile(_ != Paths.get("https")).drop(1).takeWhile(_ != initialOrg)
              if (uriFragments.isEmpty) None
              else Some(URI.create(uriFragments.map(_.toString).mkString("https://", "/", "")))
            }
        }
        .toList
        .distinct
        .filterNot(_ == Defaults.MavenCentral)

    val buildJava: Option[model.Java] =
      bloopProjectFiles
        .flatMap { case (_, p) => p.project.java.map(translateJava) }
        .reduceOption(_ intersect _)

    val buildPlatforms: Map[model.PlatformId, model.Platform] = {
      val allPlatforms = bloopProjectFiles.flatMap { case (_, p) => p.project.platform.map(translatePlatform(_, p.project)) }.toList
      List(
        allPlatforms.collect { case x: model.Platform.Jvm => x }.reduceOption(_.intersect(_)),
        allPlatforms.collect { case x: model.Platform.Js => x }.reduceOption(_.intersect(_)),
        allPlatforms.collect { case x: model.Platform.Native => x }.reduceOption(_.intersect(_))
      ).flatten.map(x => x.name -> x).toMap
    }

    val compilerPlugins: List[JavaOrScalaDependency] =
      buildPlatforms.flatMap { case (_, platform) => platform.compilerPlugin }.toList

    val buildScalas: Map[model.ScalaId, model.Scala] =
      bloopProjectFiles
        .flatMap { case (_, p) => p.project.scala.map(translateScala) }
        .groupBy(_.version.map(_.binVersion))
        .flatMap {
          case (None, _) => Map.empty
          case (Some(binVersion), scalaConfigs) =>
            val scalaVersions = scalaConfigs.flatMap(_.version).toList.distinct
            val intersected = scalaConfigs.tail.foldLeft(scalaConfigs.head)(_ intersect _)

            val withoutPlatformCompilerPlugins = {
              def keepSharedOption(name: String): Boolean =
                if (name.startsWith(Defaults.ScalaPluginPrefix)) {
                  compilerPlugins.exists { dep =>
                    scalaVersions.forall { scalaVersion =>
                      val d = dep.dependency(scalaVersion.scalaVersion)
                      !name.endsWith(s"${d.module.name}-${d.version}.jar") // scalajs-compiler_2.12.15-1.7.1.jar
                    }
                  }
                } else true

              intersected.copy(options = intersected.options.map(_.nameFilter(keepSharedOption)))
            }
            Map(model.ScalaId(binVersion) -> withoutPlatformCompilerPlugins)
        }

    val projects = bloopProjectFiles.map { case (projectName, bloopFile) =>
      val bloopProject = bloopFile.project

      val folder: Option[RelPath] = {
        RelPath.relativeTo(buildDir, bloopProject.directory) match {
          case RelPath(List(projectName.value)) => None
          case relPath                          => Some(relPath)
        }
      }

      val dependsOn: Option[JsonList[model.ProjectName]] =
        Some(JsonList(bloopProject.dependencies.map(model.ProjectName.apply).filter(bloopProjectFiles.contains)))

      val scalaVersion: Option[Versions.Scala] =
        bloopProject.scala.map(s => Versions.Scala(s.version))

      val isTest = projectName.value.endsWith("-test")
      val scope = if (isTest) "test" else "main"

      val sourcesRelPaths: List[RelPath] =
        bloopProject.sources.map(absoluteDir => RelPath.relativeTo(bloopProject.directory, absoluteDir))

      val resourcesRelPaths: List[RelPath] =
        bloopProject.resources.getOrElse(Nil).map(absoluteDir => RelPath.relativeTo(bloopProject.directory, absoluteDir))

      val resolution = bloopProject.resolution
        .getOrElse(sys.error(s"Expected bloop file for ${projectName.value} to have resolution"))

      val dependencies: List[JavaOrScalaDependency] =
        resolution.modules.map(mod => parseDependency(scalaVersion, mod))

      val configuredJava: Option[model.Java] =
        bloopProject.java
          .map { java =>
            buildJava.foldLeft(translateJava(java))((acc, buildJava) => acc.removeAll(buildJava))
          }
          .filterNot(_.options.isEmpty)

      val configuredScala: Option[model.Scala] =
        bloopProject.scala.map { scalaConfig =>
          val translated = translateScala(scalaConfig)
          translated.version match {
            case Some(version) =>
              val scalaId = model.ScalaId(version.binVersion)
              val shared = buildScalas(scalaId)
              translated.removeAll(shared).copy(`extends` = Some(scalaId))

            case None => translated
          }
        }

      val configuredPlatform: Option[model.Platform] =
        bloopProject.platform
          .map(translatePlatform(_, bloopProject))
          .map(platform =>
            model.Platform.unsafeReduce(platform, buildPlatforms(platform.name))(
              (p1, p2) => p1.removeAll(p2).copy(`extends` = Some(platform.name)),
              (p1, p2) => p1.removeAll(p2).copy(`extends` = Some(platform.name)),
              (p1, p2) => p1.removeAll(p2).copy(`extends` = Some(platform.name))
            )
          )

      projectName -> model.Project(
        folder = folder,
        dependsOn = dependsOn,
        sources = Some(JsonList(sourcesRelPaths)),
        resources = Some(JsonList(resourcesRelPaths)),
        dependencies = Some(JsonList(dependencies)),
        java = configuredJava,
        scala = configuredScala,
        platform = configuredPlatform,
        `source-layout` = None,
        `sbt-scope` = Some(scope)
      )
    }

    model.Build("1", projects, Some(buildPlatforms), Some(buildScalas), buildJava, None, resolvers = Some(JsonList(buildResolvers)))
  }

  def parseDependency(scalaVersion: Option[Versions.Scala], mod: Config.Module): JavaOrScalaDependency = {
    def withConf(dep: Dependency): Dependency =
      mod.configurations.foldLeft(dep)((dep, c) => dep.withConfiguration(Configuration(c)))

    def java: JavaOrScalaDependency.JavaDependency = {
      val dep = Dependency(Module(Organization(mod.organization), ModuleName(mod.name)), mod.version)
      JavaOrScalaDependency.JavaDependency(withConf(dep), Set.empty)
    }

    val sdep: JavaOrScalaDependency = scalaVersion match {
      case Some(scalaVersion) =>
        val full = mod.name.indexOf("_" + scalaVersion.scalaVersion)
        val scala = mod.name.indexOf("_" + scalaVersion.binVersion)
        val platform = {
          val sjs1 = mod.name.indexOf("_sjs1")
          val sjs06 = mod.name.indexOf("_sjs0.6")
          if (sjs1 != -1) sjs1 else sjs06
        }

        List(full, scala, platform).filterNot(_ == -1).minOption match {
          case None => java
          case Some(modNameEndIdx) =>
            val dep = Dependency(Module(Organization(mod.organization), ModuleName(mod.name.take(modNameEndIdx))), mod.version)
            JavaOrScalaDependency.ScalaDependency(
              withConf(dep),
              fullCrossVersion = full != -1,
              withPlatformSuffix = platform != -1,
              Set.empty
            )
        }
      case None =>
        java
    }

    import io.circe.syntax._
    import model.{decodesDep, encodesDep}
    io.circe.parser.decode[JavaOrScalaDependency](sdep.asJson.spaces2) match {
      case Left(x)  => throw x
      case Right(x) => x
    }
  }

  def translateJava(java: Config.Java): model.Java =
    model.Java(options = Some(Options(java.options)))

  def translatePlatform(platform: Config.Platform, bloopProject: Config.Project): model.Platform =
    platform match {
      case Config.Platform.Js(config, mainClass) =>
        model.Platform.Js(
          `extends` = None,
          version = Some(Versions.ScalaJs(config.version)),
          mode = Some(config.mode),
          kind = Some(config.kind),
          emitSourceMaps = Some(config.emitSourceMaps),
          jsdom = config.jsdom,
//          output = config.output.map(output => RelPath.relativeTo(bloopProject.directory, output)),
          mainClass = mainClass
        )

      case Config.Platform.Jvm(config, mainClass, runtimeConfig, classpath, resources) =>
        model.Platform.Jvm(
          `extends` = None,
          options = Some(Options(config.options)),
          mainClass,
          runtimeOptions = runtimeConfig.flatMap(rc => Some(Options(rc.options)))
        )

      case Config.Platform.Native(config, mainClass) =>
        model.Platform.Native(
          `extends` = None,
          version = Some(Versions.ScalaNative(config.version)),
          mode = Some(config.mode),
          gc = Some(config.gc),
          mainClass = mainClass
        )
    }

  def translateScala(s: Config.Scala): model.Scala = {
    val options = Options(s.options)

    val (plugins, rest) = options.values.partition {
      case Options.Opt.Flag(name) if name.startsWith(Defaults.ScalaPluginPrefix) => true
      case _                                                                     => false
    }

    val compilerPlugins = plugins.collect { case Opt.Flag(pluginStr) =>
      // /home/nnn/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scala-js/scalajs-compiler_2.12.15/1.7.1/scalajs-compiler_2.12.15-1.7.1.pom
      // todo: this should be much smarter. we can for instance read the corresponding pom file to determine coordinates
      pluginStr.split("/maven2/")(1).split("/").toList.reverse match {
        case _ :: version :: artifact :: reverseOrg =>
          parseDependency(Some(Versions.Scala(s.version)), Config.Module(reverseOrg.reverse.mkString("."), artifact, version, None, Nil))
      }
    }

    model.Scala(
      `extends` = None,
      version = Some(Versions.Scala(s.version)),
      options = Some(new Options(rest)),
      setup = s.setup.map(setup =>
        model.CompileSetup(
          order = Some(setup.order).filterNot(_ == Config.CompileSetup.empty.order),
          addLibraryToBootClasspath = Some(setup.addLibraryToBootClasspath).filterNot(_ == Config.CompileSetup.empty.addLibraryToBootClasspath),
          addCompilerToClasspath = Some(setup.addCompilerToClasspath).filterNot(_ == Config.CompileSetup.empty.addCompilerToClasspath),
          addExtraJarsToClasspath = Some(setup.addExtraJarsToClasspath).filterNot(_ == Config.CompileSetup.empty.addExtraJarsToClasspath),
          manageBootClasspath = Some(setup.manageBootClasspath).filterNot(_ == Config.CompileSetup.empty.manageBootClasspath),
          filterLibraryFromClasspath = Some(setup.filterLibraryFromClasspath).filterNot(_ == Config.CompileSetup.empty.filterLibraryFromClasspath)
        )
      ),
      compilerPlugins = Some(JsonList(compilerPlugins))
    )
  }
}
